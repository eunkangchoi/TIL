# 숫자관련 함수

## ABS = 절댓값

```sql
SELECT ABS(10.9) FROM DUAL; -- 10.9
SELECT ABS(-10.9) FROM DUAL; -- 10.9

SELECT ABS(-10) FROM DUAL; -- 10
```

<BR>

## MOD = 나머지

```sql
SELECT MOD(10, 3) FROM DUAL; -- 1
SELECT MOD(-10, 3) FROM DUAL; -- -1
SELECT MOD(10, -3) FROM DUAL; -- 1
SELECT MOD(-10, -3) FROM DUAL; -- -1
SELECT MOD (10.9, 3) FROM DUAL;  -- 1.9
```

<BR>

## ROUND = 반올림

```SQL
-- DEFAULT: 소수 첫째 자리.
SELECT ROUND(123.456) FROM DUAL; -- 123
SELECT ROUND(123.678) FROM DUAL; -- 124

SELECT ROUND(123.678, 0) FROM DUAL; --124 소수첫번째 자리 반올림.
-- 0인덱스 기반

SELECT ROUND(123.678, 1) FROM DUAL; -- 123.7 (소수 둘째자리)
SELECT ROUND(123.678, 2) FROM DUAL; -- 123.68 (소수 셋째자리)

SELECT ROUND(123.456, -2) FROM DUAL; -- 100 (소수 -2번째 자리=십의자리)

SELECT ROUND(-10.61) FROM DUAL; -- -11
-- -10.1 => -10에 가까움 => -10
-- -10.56 => -11에 가까움. => -11
```

<BR>

## FLOOR: 내림

```SQL
SELECT FLOOR(123.456) FROM DUAL; --123
SELECT FLOOR(123.678) FROM DUAL; --123
```

<BR>

## TRUNC : 잘라놓음.
```sql
SELECT TRUNC (123.456) FROM DUAL; --123
SELECT TRUNC (123.678) FROM DUAL; --123
SELECT TRUNC(123.456, 1) FROM DUAL; --123.4
SELECT TRUNC(123.456, -1) FROM DUAL; --120 (1의자리숫자에서 그이하 싹다제거.)
```

<BR>

## CEIL : 올림
```sql
SELECT CEIL(123.456) FROM DUAL; --123
SELECT CEIL(123.678) FROM DUAL; --124
```

<BR>

<HR>

# 날짜 관련 함수

## SYSDATE : 시스템상에 저장되어있는 현재날짜로 변환
```sql
SELECT SYSDATE FROM DUAL;
```

<BR>

## MONTH_BETWEEN : 개월 수의 차이를 숫자로 리턴
```SQL
-- EMPLOYEE 테이블에서 사원의 이름, 입사일, 근무 개월 수 조회
-- MONTH_BETWEEN(SYSDATE, HIRE_DATE)= SYSDATE-HIRE_DATE 와 같음.
SELECT EMP_NAME, HIRE_DATE, MONTH_BETWEEN(SYSDATE,HIRE_DATE)
FROM EMPLOYEE;

-- ABS: 절댓값=> 양수로 한다.
-- CEIL: 올림
SELECT EMP_NAME, HIRE_DATE, CEIL(ABS(MONTH_BETWEEN(SYSDATE,HIRE_DATE))) || '개월 차' 근무개월
FROM EMPLOYEE;
```

<BR>

## ADD_MONTHS: 개월 수를 더해 날짜를 리턴
```sql
SELECT ADD_MONTHS(SYSDATE, 5) FROM DUAL; --현재날짜에서 5개월을 더한다.
SELECT ADD_MONTHS(SYSDATE, 6) FROM DUAL; --현재날짜에서 6개월을 더한다

-- EMPLOYEE 테이블에서 사원의 이름과 입사일, 입사후 6개월이 되는 날짜 조회
SELECT EMP_NAME "사원 이름", HIRE_DATE 입사일, ADD_MONTHS(HIRE_DATE, 6) "입사후 6개월 날짜"
FROM EMPLOYEE;
```

<BR>

## NEXT_DAY: 기준 날짜에 대해서 구하려는 요일에 가장 가까운 날짜를 리턴
```SQL
SELECT SYSDATE, NEXT_DAY(SYSDATE, '목요일') FROM DUAL;
-- 오늘날짜로부터 목요일=> 7/9
-- 오늘날짜 => 7/6

SELECT SYSDATE, NEXT_DAY(SYSDATE, 5) FROM DUAL;
-- 오늘날짜로부터 목요일
-- 일 월 화 수 목  금  토
-- 1  2  3  4  5  6  7


SELECT SYSDATE, NEXT_DAY(SYSDATE, '목') FROM DUAL;


SELECT SYSDATE, NEXT_DAY(SYSDATE, 'THURSDAY') FROM DUAL; -- 한글 기반언어라서, ERROR

--언어 변경: 한국어 -> 영어(미국)
ALTER SESSION SET NLS_LANGUAGE=AMERICAN; -- 영어로 변경
SELECT SYSDATE, NEXT_DAY(SYSDATE, 'THURSDAY') FROM DUAL; -- 목요일로 됨.
SELECT SYSDATE, NEXT_DAY(SYSDATE, 'THU') FROM DUAL; -- 목요일로 됨.

-- 언어변경: 영어-> 한국어
ALTER SESSION SET NLS_LANGUAGE=KOREAN;

-- LAST_DAY: 해당 달에 마지막 날짜를 구해서 리턴
SELECT SYSDATE, LAST_DAY(SYSDATE) FROM DUAL;
```

<BR>

> # 실습문제(숙제)

```sql
-- EMPLOYEE 테이블에서 사원명, 입사일-오늘, 오늘-입사일 조회
-- 단, 별칭은 근무일수1, 근무일수 2로 하고 모두 정수처리(내림), 양수가 되도록 처리
SELECT EMP_NAME "사원명", FLOOR(ABS(MONTH_BETWEEN(HIRE_DATE, SYSDATE))) "근무일수1",
          FLOOR(ABS(MONTH_BETWEEN(SYSDATE, HIRE_DATE))) "근무일수2"
FROM EMPLOYEE;


-- EMPLOYEE 테이블에서 사번이 홀수인 직원들의 정보를 모두 조회
SELECT *
FROM EMPLOYEE
WHERE EMP_ID %2=1;

-- EMPLOYEE 테이블에서 근무 년수가 20년 이상인 직원 정보 조회
SELECT *
FROM EMPLOYEE
WHERE ABS(MONTH_BETWEEN(HIRE_DATE, SYSDATE))

-- EMPLOYEE 테이블에서 사원 명, 입사일, 입사한 달의 근무 일 수 조회.

```


## EXTRACT : 년/ 월/ 일 정보를 추출하여 리턴

```sql
-- EMPLOYEE 테이블에서 사원의 이름, 입샤년도, 입사월, 입사일 조회
SELECT EMP_NAME, EXTRACT(YEAR FROM HIRE_DATE) "입사년도", EXTRACT(MONTH FROM HIRE_DATE) 입사월,
      EXTRACT(DAY FROM HIRE_DATE) 입사일
FROM EMPLOYEE;


-- EMPLOYEE 테이블에서 사원의 이름, 입사일, 근무년수 조회
SELECT EMP_NAME "사원의 이름", HIRE_DATE "입사일",
      (EXTRACT(YEAR FROM SYSDATE) - EXTRACT(YEAR FROM HIRE_DATE)) "근무 년수"
FROM EMPLOYEE;


SELECT EMP_NAME, HIRE_DATE "입사일", FLOOR(MONTHS_BETWEEN(SYSDATE, HIRE_DATE)/12) "근무 년수"
FROM EMPLOYEE;
```


<BR>

# 형변환 함수

## TO_CHAR: 숫자/날짜형 데이터를 문자형 데이터로 변경

```SQL
SELECT TO_CHAR(123) FROM DUAL; -- 숫자-> 문자로 변경.

SELECT TO_CHAR(1234,'99999') 확인 FROM DUAL;
-- ' '1234
--다섯칸을 만들어놓고 -> 오른쪽에 차례대로넣고-> 빈칸은 공백으로 두겠다.

SELECT TO_CHAR(1234,'00000') 확인2 FROM DUAL; --
-- 01234

SELECT TO_CHAR(1234, 'L99999') FROM DUAL; --      (원화)1234

-- FM원화앞에있는 공백제거
SELECT TO_CHAR(1234,'FML99999') FROM DUAL; -- (원화)1234

SELECT TO_CHAR(1234,'FM$99999') FROM DUAL; -- $1234
SELECT TO_CHAR(1234,'99,999') FROM DUAL; -- 1,234
SELECT TO_CHAR(1234, 'FM99,999') FROM DUAL; -- 1,234
SELECT TO_CHAR(1234,'00,000') FROM DUAL; -- 01,234
SELECT TO_CHAR(1234, '999') FROM DUAL; -- #### (넣을수있는 칸보다 더 많은 글자를 넣으려고 할때 #으로 채워짐 ㅠ)


-- EMPLOYEE 테이블에서 사원명, 급여조회(급여는 \9,000,000 형식으로 표시)
SELECT EMP_NAME "사원명", TO_CHAR(SALARY, 'FML9,999,999') "급여"
FROM EMPLOYEE;


-- 시간 형식대로 나타내기
-- PM: 오전/오후
-- HH24: 24시간 기준/ 0시~23시
-- MI: 분
-- SS: 초
SELECT TO_CHAR(SYSDATE, 'PM HH24:MI:SS') FROM DUAL;


-- 시간 형식대로 나타내기2
-- HH: 12시간 기준.
SELECT TO_CHAR(SYSDATE, 'AM HH:MI:SS') FROM DUAL;


-- 시간 형식대로 나타내기3
-- MON: 월/ DY: 일 / YYYY: 년도
SELECT TO_CHAR(SYSDATE, 'MON DY YYYY') FROM DUAL;


-- DAY: 요일(일월화수목금)
SELECT TO_CHAR(SYSDATE, 'YYYY-MM-DD DAY') FROM DUAL;


-- FM적용=> MM, DD, DAY 모두 적용.
-- FM: 공백제거.
SELECT TO_CHAR(SYSDATE, 'YYYY-FMMM-DD DAY') FROM DUAL;


-- Q: 분기
-- 1,2,3: 1분기
-- 4,5,6: 2분기
-- 7,8,9: 3분기
-- 10,11,12: 4분기
SELECT TO_CHAR(SYSDATE, 'YEAR, Q') FROM DUAL;

```


> ## 퀴즈

```SQL
-- EMPLOYEE 테이블에서 이름, 입사일 조회 (예: 2020년 07월 06일 (월))
SELECT  EMP_NAME, TO_CHAR(HIRE_DATE, 'YYYY"년" MM"월" DD"일" "("DY")"') 입사일
FROM EMPLOYEE;
```

<BR>

## TO_DATE : 문자/숫자형 데이터를 날짜형 데이터로 변환

```SQL
SELECT TO_DATE('20200101', 'YYYYMMDD') FROM DUAL;

SELECT TO_DATE('20200101', 'YYYYMMDD') FROM DUAL;


SELECT TO_CHAR(TO_DATE('20200706', 'YYYYMMDD'), 'YYYY, MON') FROM DUAL; -- 2020, 7월

SELECT TO_CHAR(TO_DATE('201221 153000', 'YYMMDD HH24MISS'), 'YY-MM-DD HH:MI:SS PM') FROM DUAL;
-- 20년 12월 21일 03:30:00 오후


-- YYMMDD => 현재세기가 붙음
-- RRMMDD => 내가 들어온 세기에 따라서, 이전세기가 붙을 수 있고, 현재세기가 붙음
-- 50이상이면 현재세기
-- 50미만이면 이전세기가 붙음.
SELECT  TO_CHAR( TO_DATE('981212', 'YYMMDD'), 'YYYYMMDD') "YY98",
        TO_CHAR( TO_DATE('121212', 'YYMMDD'), 'YYYYMMDD')  "YY12",
        TO_CHAR( TO_DATE('981212', 'RRMMDD'), 'YYYYMMDD') "RR98",
        TO_CHAR( TO_DATE('121212', 'RRMMDD'), 'YYYYMMDD') "RR12"
FROM DUAL;
-- YY98     YY12     RR98     RR12
-- 20981212 20121212 19981212 20121212
```


## TO_NUMBER : 문자형 데이터를 숫자형 데이터로 변환
```sql
SELECT TO_NUMBER('123456789') FROM DUAL; -- 579

SELECT '123' + '456' FROM DUAL;
SELECT '123' + '456A' FROM DUAL; -- error Invalid number

SELECT '1,000,000' + '550,000' FROM DUAL; -- ERROR INVALID NUMBER

SELECT TO_NUMBER('1,000,000', '99,999,999') FROM DUAL; -- 1000000

SELECT TO_NUMBER('1,000,000', '9,999,999') + TO_NUMBER('550,000', '999,999')
FROM DUAL;
```


# NULL 처리 함수

## NVL
```sql
SELECT EMP_NAME, BONUS
FROM EMPLOYEE;

-- BONUS가 NULL이면 0으로 대체
SELECT EMP_NAME, BONUS, NVL(BONUS,0)
FROM EMPLOYEE;

-- DEPT_CODE가 NULL이면 '없습니다' 로 대체
SELECT EMP_NAME, DEPT_CODE, NVL(DEPT_CODE, '없습니다')
FROM EMPLOYEE;
```


## NVL2
- NVL2(컬럼, 바꿀값1, 바꿀값2)
- 해당 컬럼의 값이 있으면 바꿀값1로 변경
- 해당 컬럼의 값이 없으면 바꿀값2로 변경

```SQL
-- EMPLOYEE 테이블에서 보너스가 NULL인 직원은 0.5
-- NULL이 아닌 직원은 0.7로 변경
SELECT EMP_NAME, BONUS, NVL2(BONUS, 0.7, 0.5)
FROM EMPLOYEE;



```


## NULLIF
```SQL
-- NULLIF
-- 두개의 값을 비교할때 같으면 NULL을 반환, 다르면 앞의 비교대상 1을 반환
SELECT NULLIF(123, 123) FROM DUAL;
SELECT NULLIF(123, 124) FROM DUAL; --123
```

## DECODE: 삼항연산자와 switch-case문 유사
- DECODE(계산식|컬럼명, 조건값1, 선택값1, 조건값2, 선택값2, ...)
```SQL

-- 계산식 결과 혹은 컬럼값이 조건식의 결과값과 같으면 선택값 반환
-- SUBSTR(EMP_NO, 8, 1) => EMP_NO컬럼값에서 8번째 자리에서 1글자 추출.
-- DECODE: 선택 함수
-- SUBSTR(~) 이 (조건값1) 1이면-> (선택값1)'남자'
-- SUBSTR(~) 이 (조건값2) 2이면-> (선택값2)'여자'
SELECT EMP_ID, EMP_NAME, EMP_NO, DECODE(SUBSTR(EMP_NO, 8,1), 1, '남자', 2, '여자') "성별"
FROM EMPLOYEE;

-- 조건에 아무것도 해당하지 않을때 (선택값2)인 '여자'로 됨.
-- 즉, 조건에 아무것도 해당하지 않을 때, 마지막에 작성한 선택값으로 자동선택됨.
SELECT EMP_ID, EMP_NAME, EMP_NO, DECODE(SUBSTR(EMP_NO, 8,1), 1, '남자', '여자') "성별"
FROM EMPLOYEE;

```


> ## 퀴즈
```SQL
```
