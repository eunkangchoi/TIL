# 기술면접 대비 - 기본기 정리

<details>
  <summary>빠르게 보기</summary>

- [:pencil2: No SQL vs SQL](#nosql-과-sql-차이점)
- [:pencil2: Process vs Thread](#프로세스와-스레드)
- [:pencil2: Multip Process vs Multi Thread](#멀티프로세스와-멀티스레드)
- [:pencil2: Cache](#캐시cache)
- [:pencil2: Docker](#docker의-정의)
- [:pencil2: Kubernetes](#쿠버네티스-정의)
- [:pencil2: JWT](#jwt)
- [:pencil2: Agile ](#agile-방법론)
- [:pencil2: Transaction](#트랜잭선transaction-정의)
- [:pencil2: 객체지향 프로그래밍(OOP)](#객체지향-프로그래밍-정의)
- [:pencil2: 클리스/객체/인스턴스 ](#클래스--객체--인스턴스)
- [:pencil2: Override vs Overload](#오버라이딩override와-오버로딩overloading)
- [:pencil2: OS](#운영체제operating-system)
- [:pencil2: REST](#restful-api)
- [:pencil2: Library vs Framework](#라이브러리와-프레임워크의-차이점)
- [:pencil2: DevOps](#devops-란)
- [:pencil2: Cloud](#aws-gcp-클라우드)
- [:pencil2: HTTP & HTTPS](#http-프로토콜이란)
- [:pencil2: GET vs POST](#get과-post방식)
- [:pencil2: Stack vs Queue](#stack과-queue의-정의)
- [:pencil2: Database - Index ](#인덱스index)
- [:pencil2: TCP와 UDP](#tcp-와-udp)
- [:pencil2: 힙(heap)과 스택(stack)](#힙heap과-스택stack)
- [:pencil2: 해시테이블(hash table)](https://github.com/loveAlakazam/TIL/blob/master/2021/Back_to_the_Basic/%EC%BB%B4%EA%B3%B5%EA%B8%B0%EB%B3%B8%EA%B8%B0%EC%A0%95%EB%A6%AC.md#%ED%95%B4%EC%8B%9C%ED%85%8C%EC%9D%B4%EB%B8%94hash-table)
- [:pencil2: N:N 테이블](https://github.com/loveAlakazam/TIL/blob/master/2021/Back_to_the_Basic/%EC%BB%B4%EA%B3%B5%EA%B8%B0%EB%B3%B8%EA%B8%B0%EC%A0%95%EB%A6%AC.md#nn-%ED%85%8C%EC%9D%B4%EB%B8%94)
- [:pencil2: 이분탐색](#이분탐색binary-search)
- [:pencil2: 인터페이스와 상속](#인터페이스interface와-상속)
- [:pencil2: 싱글톤 패턴](#싱글톤-패턴singleton)
- [:pencil2: 옵져버패턴](#https://github.com/loveAlakazam/TIL/blob/master/2021/Back_to_the_Basic/%EC%BB%B4%EA%B3%B5%EA%B8%B0%EB%B3%B8%EA%B8%B0%EC%A0%95%EB%A6%AC.md#%EC%98%B5%EC%A0%B8%EB%B2%84-%ED%8C%A8%ED%84%B4observer)
- [:pencil2:](#)
- [:pencil2:](#)

</details>

<br><br>

> ## NoSQL 과 SQL 차이점?

![](./img1/ex1.png)

### SQL (Structured Query Language)

- 관계형 데이터베이스
- 데이터의 형식이 구조화되어있다.
- 스키마에 따라 데이터베이스 테이블에 저장된다.

  - _스키마 (scheme)_
    - 데이터 구조와 제약조건에 관한 전반적인 명세를 기술한 메타데이터의 집합
    - 데이터베이스를 구성하는 개체(Entity), 속성(Attribute), 관계(Relationship) 및 데이터 조작시 데이터 값들이 갖는 제약조건등에 관해 전반적으로 정의한다.
  - Attribute(속성) : 개체의 특성을 나타냄(컬럼)
  - Entity(개체) : 속성들의 집합을 의미한다.

- 데이터 구조가 매우 엄격하다.
- 데이터의 일관성을 보증한다.
- 정규화에 따른 갱신비용을 최소화 한다.
- 시스템복잡도를 고려하여 구조화 해야한다.
- 행과 열로 구성되어있고, 엑셀시트처럼 2차원 배열 형태로 형식이 정해져있다.
- 데이터에서 어떤 데이터를 얻을지에 대한것은 편함. (**컬럼을 통해서 데이터를 쉽게 얻을 수 있다.**)

<br>

### No SQL (Not Only SQL)

No SQL은 세종류가 존재한다.

- 데이터간의 관계를 정의하지 않는다.
  - 반대로, sql은 데이터간의 관계를 정의한다.
- collection 이라는 형태로 데이터를 관리한다.
- 대용량 데이터를 저장할 수 있다.
- 분산형 구조
- 유연한 데이터 모델링
- 수평적 확장이 쉽다 (컬럼추가와 같은 것들)
- 컬렉션에 중복된 데이터가 저장이 될 수 있다.

<br><br>

- ### **Document DB**
  - **Mongo DB**가 대표적이다.
  - **데이터를 JSON 형태로 저장**한다.
  - 형태가 구조화되어있지 않아서 어떤 형태로든지 저장이 가능하다.

![](./img1/ex2.png)

<br>

- ### **Key Value DB**

  - **Cassandra DB**와 **Dynamo DB**가 대표적이다.

  - #### **Cassandra DB**

    - column wide database
    - **읽기, 쓰기 가 겁나 빠르다.**
    - **많은 양의 데이터를 빠르게 저장하고 읽을 수 있다.**
    - 많은양의 데이터를 빨리 읽어야되는 *검색 엔진*에 많이 쓰인다.

  - #### **Dynamo DB**
    - 아마존에서 만든 데이터베이스
    - 서버리스(serverless) key value database
    - 매초에 2400000개를 읽는다.
    - 저장하기전에 db에 무엇을 얻을 것인지를 미리 생각해야됨.

- ### **Graph DB**
  - column과 document가 필요없을 때
  - 각각의 entity를 저장하고 이를 관계망으로 연결하는 것.
  - 각노드 간의 관계를 알 때 필요하다.
  - 페이스북이 graph db를 사용. (tao)
  - 유저 1이 좋아요를 누르면 => 유저1의 친구에게 공유할 수 있다.

![](./img1/ex3.png)

<br>

- 참고
  - https://www.youtube.com/watch?v=Q_9cFgzZr8Q
  - https://www.youtube.com/watch?v=z9chRlD1tec
  - https://github.com/HyeminNoh/Tech-Stack/blob/master/docs/Database/RDBMS_and_NoSQL.md

[[🔝위로가기]](#)

<br>

> ## 프로세스와 스레드

> ### 프로세스 (process)

- 1. 정의
  - 어떤 작업을 위해 **실행할 수 있는 파일**
  - **프로그램을 메모리 상에서 실행중인 작업**
  - 메모리에 올라와 실행되고 있는 프로그램의 인스턴스
  - 운영체제로부터 시스템 자원을 할당받는 작업의 단위
    - 시스템 자원
      - CPU 시간
      - 주소 공간
      - 메모리 영역
  - 실행된 프로그램
- 2. 특징
  - 프로세스는 각각 독립된 메모리 영역(code, data, stack, heap)을 할당 받는다.
  - 프로세스 당 최소 1개의 스레드(main thread)를 갖는다.
  - 각 프로세스는 별도의 주소공간에서 실행된다.
  - 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없다.
  - 한 프로세스가 다른프로세스 자원에 접근하려면 프로세스간의 통신(IPC, Inter-Process Communication)을 사용해야한다.
    - 예) 파이프, 파일, 소켓 등을 이용한 통신 방법

<br>

> ### 스레드 (Thread)

- 1. 정의
  - 프로세스 안에서 실행되는 여러흐름 단위
  - 프로세스의 특정한 수행 경로
  - 프로세스가 할당받은 자원을 이용하는 실행의 단위
  - 스레드는 프로세스 내에서 각각 stack만 할당 받는다.
    - code, data, heap영역은 공유한다.
  - 프로세스 내의 주소 공간이나 자원들(힙공간)을 같은 프로세스 내에서 스레드끼리 공유하면서 실행된다.
  - 같은 프로세스 안에 있는 여러 스레드들은 같은 힙공간을 공유한다.
  - 프로세스는 다른 프로세스의 메모리에 직접 접근할 수 없다.
  - 각 스레드들은 별도의 레지스터와 스택을 갖는다.
  - 힙메모리는 서로 읽고 쓸 수 있다.
  - 한 스레드가 프로세스 자원을 변경하면, 다른 이웃 스레드도 그 변경 결과를 즉시 볼 수 있다.

<br>

- 참고 자료
  - https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html

[[🔝위로가기]](#)

<br>

> ## 멀티프로세스와 멀티스레드

> ### 1. 멀티 프로세스

- 멀티프로세싱(multi processing)

  - 정의

    - 하나의 응용프로그램을 여러개의 프로세스로 구성한다.
    - 각 프로세스가 하나의 작업(task)을 처리하도록 한다.

  - 장점
    - 여러개의 자식 프로세스 중 하나에 문제가 발생하면, 그 자식 프로세스만 죽고 다른 프로세스에게 영향을 주지 않는다.
  - 단점

    - 1. `context switching`에서의 오버헤드가 발생한다.
      - 캐시 메모리 초기화등 무거운 작업이 진행되고 많은 시간이 소모되는 오버헤드가 발생한다.
      - 프로세스는 각각의 독립된 메모리 영역을 할당받기 때문에 프로세스 사이에서 공유하는 메모리가 없다.
      - `context switching`이 발생하면 캐시에 있는 모든 데이터를 리셋하고 다시 캐시정보를 불러와야한다.
    - 2. 프로세스 사이의 어렵고 복잡한 통신기법

      - 프로세스는 각각의 독립된 메모리영역을 할당 받기 때문에, 하나의 프로개름에 속하는 프로세스들 사이의 변수를 공유할 수 없다.

    - (참고) `Context Switching`?
      - 프로세스의 상태정보를 저장하고 복원하는 일련의 과정이다.
      - CPU에서 여러 프로세스를돌아가면서 작업을 처리한다.
      - 동작중인 프로세스가 대기를 하면서 해당 프로세스의 상태(context)를 보관하고, 대기하고 있던 다음 순서의 프로세스가 동작하면서 이전에 보관했던 프로세스의 상태를 복구하는 작업을 의미한다.

<br><br>

> ### 2. 멀티 스레드

- 멀티 스레딩(multi threading)

  - 정의

    - **하나의 응용프로그램을 여러개의 스레드**로 구성하고, 각 스레드로 하여금 하나의 작업을 처리하도록 하는 것이다.
    - 윈도우 리눅스 등 많은 운영체제들이 멀티프로세싱을 지원하고 있지만 멀티스레딩을 기본으로 하고있다.
    - 웹서버는 대표적인 멀티 스레드 응용프로그램이다.

  - 장점
    - 시스템 자원 소모 감소 (자원의 효율성 증대)
      - 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있다.
    - 시스템 처리량 증가 (처리비용 감소)
      - 스레드 간 데이터를 주고받는 것이 간단하다
      - 시스템 자원 소모가 줄어든다.
    - 간단한 통신방법으로 인한 프로그램 응답 시간 단축
      - 스레드는 프로세스 내의 stack영역을 제외한 모든 메모리를 공유하기 때문에 통신부담이 적다.
  - 단점
    - 주의 깊은 설계가 필요하다.
    - 디버깅이 까다롭다.
    - 단일 프로세스 시스템의 경우 효과를 기대하기 어렵다.
    - 다른 프로세스에서 스레드를 제어할 수 없다.
      - 프로세스 밖에서 스레드 각각을 제어할 수 없다.
    - 멀티 스레드의 경우 자원 공유의 문제가 발생한다(동기화 문제)
      - 동기화
      - 스레드 간의 자원 공유는 전역변수(데이터 세그먼트)를 이용하므로 함께 상용할 때 충돌이 발생할 수 있다.
    - 하나의 스레드에 문제가 발생하면 전체 프로세스가 영향을 받는다.

<br><br>

> ### 멀티 프로세스 대신에 멀티스레드를 사용하는 이유는?

- #### 프로그램을 여러개 켜는 것보다, 하나의 프로그램 안에서 여러 작업을 해결한다.

- #### 자원의 효율성 증대

  - 멀티프로세스로 실행되는 작업을 멀티 스레드로 실행할 경우, **프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어**들기 때문에 자원을 효율적으로 관리할 수 있다.

  - 프로세스간의 context switching시 단순히 cpu레지스터 교체뿐만 아니라 RAM과 CPU 사이의 캐시 메모리에 대한 데이터까지 초기화되므로 오버헤드가 크기 때문이다.

  - 스레드는 프로세스 내의 메모리를 공유하기 때문에 독립적인 프로세스와 달리 스레드간 데이터를 주고받는 것이 간단해지고 시스템 자원 소모가 줄어들게 된다.

- #### 처리 비용 감소 및 응답 시간 단축

  - 프로세스 간의 통신(IPC)보다 스레드간의 통신의 비용이 적으므로 작업들 간의 통신의 부담이 줄어든다.
  - 스레드는 stack영역을 제외한 모든 메모리를 공유한다.
  - 프로세스 간의 전환 속도보다 스레드간의 전환 속도가 빠르다.
  - context switching시 스레드는 stack영역만을 처리한다.

- 참고자료
  - https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html

[[🔝위로가기]](#)

<br>

> ## 캐시(Cache)

- 속도가 빠른 장치와 느린 장치에서 속도 차이에 따른 병목 현상을 줄이기 위한 메모리를 의미한다.

- CPU는 주기억 장치에서 저장된 데이터를 읽어올 때, 자주 사용하는 데이터를 캐시메모리에 저장한 뒤, 다음에 이용할 때 주기억장치가 아닌 캐시메모리에서 먼저 가져오면서 속도를 향상 시킨다.

<br>

> ## Docker의 정의

- Docker은 `environment disparity` 문제를 해결한다.

  - environment disparity란?
    - 개발한 것을 서버에 올렸는데, 서버에 올리니까 안됨.
    - OS에 따라 생성

- Docker is a standalone software that can be installed on any computer to run containerized applications.

  - Docker은 컴퓨터의 OS상관없이 컨테이너화된 어플리케이션들을 설치할 수 있는 독립적인 소프트웨어

- Containerization

  - Containerization is an approach of running applications on an OS such that the application is isolated from the rest of the system.
  - 컨테이너화는 애플리케이션이 시스템의 나머지 부분과 분리되도록 os에서 애플리케이션을 실행하는 접근 방식이다.

- Docker is what enables us to run, create and manage containers on a single operating system.

  - Docker은 단일 OS에서 컨테이너들을 실행, 생성 및 관리 할 수 있도록 지원한다.

- 참고자료
  - https://containerjournal.com/topics/container-ecosystems/kubernetes-vs-docker-a-primer/

[[🔝위로가기]](#)

<br>

> ## 쿠버네티스 정의

- If you have Docker installed on a bunch of hosts(different operating system), you can leverage Kubernetes.

  - 여러 호스트(다른 운영체제)에 Docker가 설치되어있는 경우 Kubernetes를 활용할 수 있다.

- Kubernetes can then allow you to automate container provisioning, networking, load-balancing, security and scaling across all these nodes from a single command line or dashboard.

  - Kubernetes는 대시보드의 한 개명령어로부터 모든노드들에 걸쳐서 컨테이너를 권한설정(provisioning), 네트워킹, 부하균형(로드 밸런싱, load-balancing), 보안 및 확장을 자동화 해줄 수 있다.

- A collection of nodes that is managed by a single Kubernetes instance is referred to as Kubernetes Cluster
  - 단일 Kubernetes 인스턴스로부터 관리되는 노드의 집합체들은 Kubernetes Cluster라고 불린다.

[[🔝위로가기]](#)

<br>

> ## JWT

[[🔝위로가기]](#)

<br>

> ## 쿠키(Cookie)와 세션(Session)

- 정리
  - 쿠키(cookie)
    - **사용자 컴퓨터에 저장**
    - 저장된 정보를 다른 사람 또는 시스템이 볼 수 있다.
    - 유효시간이 지나면 사라진다.
  - 세션(session)
    - **서버에 저장된다.**
    - 서버나 브라우저가 종료되거나, 유효시간이 지나면 사라진다.
    - 보안에 좋다.

<br>

- ### 쿠키 동작 과정

![](./img1/e1.png)

![](./img1/e2.png)

<br>

- 왜 쿠키(cookie)와 세션(session)을 사용하나?

  - http 프로토콜은 connectionless, stateless한 특성을 갖고있다.
  - 비연결성(connectionless) : 클라이언트가 서버에 요청을 한 후 응답을 받으면 **맺었던 연결을 끊는 특성**
  - 무상태성(stateless) : 서버와 클라이언트 사이의 통신이 끝나면 **상태를 유지하지 않는 특성**

<br>

- 상태를 모르면...아래와 같이 **클라이언트가 누군지 확인하기 위해서 인증을 반복**해야된다. 이는 HTTP 프로토콜 특성으로 인한 단점이라서 `쿠키`와 `세션`이 필요하다.

```
쇼핑몰에 접속
로그인
상품클릭 -> 상세화면 이동
로그인
주문
로그인
...
```

- ### 쿠키(Cookie)
  - **클라이언트의 상태정보를 로컬에 저장한 key-value형식의 데이터 파일**
  - 클라이언트 정보파일을 브라우저에 저장한다.
  - **클라이언트 로컬에 저장되는 키와 값**이 들어있는 작은 데이터 파일
  - 사용자 인증이 유효한 시간을 명시할 수 있다.
    - 유효시간이 정해지면 브라우저가 종료되어도 인증이 유지된다.
  - **클라이언트의 상태 정보를 로컬에 저장했다가 참조한다.**
  - Response Header에 Set-cookie 속성을 사용하면 클라이언트에 쿠키를 만들 수 있다.
  - 쿠키는 사용자가 따로 요청하지 않아도, 브라우저가 Request시 Request Header를 넣어서 자동으로 서버에 전송한다.
  - 쿠키의 구성요소
    - 이름(key): 쿠키를 구별하는데 사용하는 이름
    - 값(value): 쿠키의 이름과 관련된 값
    - 유효시간: 쿠키의 유지시간
    - 도메인 : 쿠키를 전송할 도메인
    - 경로: 쿠키를 전송할 요청경로

<br>

- ### 세션(Session)

  - 쿠키를 기반하고 있다.
  - 세션(Session)은 서버 측에서 관리하고 있다.
  - **클라이언트를 구분하기 위해 세션 id를 부여**한다.

    - session id : 클라이언트가 Request를 보내면 해당서버의 엔진이 클라이언트에게 유일한 id를 부여한다.

  - **웹브라우저가 서버에 접속해서 브라우저가 종료할 때까지 인증상태를 유지**한다.
  - 동시 접속자 수가 많은 경우에는 서버메모리에 여러사용자의 정보를 저장해야되므로 서버에 과부하가 발생하여 성능저하가 생길 수 있다.
  - 특징
    - 세션 ID로 클라이언트를 구분해서 클라이언트의 요구에 맞는 서비스를 제공한다.
    - 쿠키보다 보안면에서 우수하다.

<br>

- ### 세션 동작과정

![](./img1/s1.png)

![](./img1/s2.png)

<br>

> ### 쿠키와 세션은 어떤 차이점을 갖는가?

- 1. 서버의 자원을 사용하는가?

  - 쿠키는 서버의 자원을 전혀 사용하지 않는다.
  - 세션은 서버의 자원을 사용한다.

- 2. 보안

  - 세션은 쿠키보다 보안면에서 우수하다.
  - 쿠키는 세션보다 요청속도가 빠르다.
    - 세션은 서버의 처리가 필요하다.
  - 쿠키는 클라이언트 로컬에 저장되기때문에 변질되거나 request에서 sniffing을 당할 우려가 있어서 보안에 취약하다.
  - 반면, 세션은 쿠키를 이용해서 session id만 저장하고 id로 구분하여 서버에서 처리하기때문에 보안성이 좋다.

- 3. 만료시간
  - 쿠키는 파일로 저장되기때문에 브라우저를 종료해도 (유효시간이 지나지 않으면) 정보가 남아있다.
  - 세션은 만료시간을 정할 수있지만, 브라우저가 종료되면 만료시간 상관없이 삭제된다.
  - 세션의 정보는 서버에서 처리를 하기때문에 쿠키보다 속도가 느리다.

[[🔝위로가기]](#)

<br>

> ## 배열과 리스트(Linked List)는 어떤차이점을 갖는가?

[[🔝위로가기]](#)

<br>

> ## Agile 방법론

[[🔝위로가기]](#)

<br>

> ## 트랜잭션(Transaction) 정의

- 트랜잭션은 **데이터의 상태를 변화시키기 위해 수행하는 작업단위** 이다.
  - 상태변화 : `CREATE`, `INSERT`, `UPDATE`, `DELETE` 를 의미한다.
  - 작업단위: 많은 SQL명령문들을 사람이 정하는 기준에 따라 정하는 것을 의미한다.
    - `COMMIT` 은 여러개 트랜잭션이 모두 성공적으로 완료하는 것을 의미한다.
    - `ROLLBACK` 은 트랜잭션이 쿼리문중 하나라도 실패했을 때, 이전상태로 되돌려야한다.

<br>

- 트랜잭션의 특징

  - 원자성: 트랜잭션이 데이터베이스에 모두 반영되거나, 전혀 반영이 되지 않음을 의미한다.
  - 일관성: 트랜잭션의 작업처리 결과는 항상 일관성이 있어야한다.
  - 독립성: 둘 이상의 트랜잭션이 동시에 병행 및 실행되고 있을 때 어떤 트랜잭션도 다른 트랜잭션 연산에 끼어들 수 없다.
  - 지속성: 트랜잭션이 성공적으로 완료되었으면 결과는 영구적으로 반영해야된다.

- 데이터베이스의 논리적인 기능을 수행하기 위한 일련의 연산집합이며, **작업의 단위**이다.

- 트랜잭션은 데이터베이스 관리 시스템에서 회복 및 병행제어 시에 처리되는 **작업의 논리적인 단위**이다.

- 데이터베이스의 일관성(consistency) 상태를 갖는다.

[[🔝위로가기]](#)

<br>

> ## 객체지향 프로그래밍 정의

> ### 다형성(Polymorphism)

- 예: (부모클래스) 도형 / (자식클래스) 원, 삼각형
- #### 상속이 기본되는 전제 부모타입으로부터 파생된 여러가지 타입의 자식객체를 **`부모클래스 타입 하나로 다룰 수 있는 기술`**을 의미한다.
- #### **`상속`** : **자식객체는 부모클래스의 타입을 물려받을 수 있다.**
- 모든 객체의 부모는 Object 클래스이다.
- 업캐스팅(upcasting) : 상속관계에 있는 부모, 자식 클래스간에 부모타입의 참조형 변수가 모든 자식 타입 객체 주소를 받을 수 있음.

<br>

> ### 캡슐화

<br>

> ### 상속

<br>

> ### 추상화

- 추상클래스
- 인터페이스

<br>

[[🔝위로가기]](#)

<br>

> ## 클래스 / 객체 / 인스턴스

> ### 클래스(class)

- 객체를 만들어 내기위한 설계도(틀)
- 연관되어있는 변수와 메소드의 집합

<br>

> ### 객체(Object)

- 소프트웨어 세계에 구현할 대상
- 클래스에 선언된 모양 그대로 생성된 실체

- 클래스의 인스턴스라고 불린다.
- 객체는 모든 인스턴스를 대표하는 포괄적인 의미를 갖는다.

<br>

> ### 인스턴스(Instance)

- 설계도를 바탕으로 소프트웨어 세계에 구현된 구체적인 실체

  - 객체를 소프트웨어에 실체화한 것.
  - 실체화된 인스턴스는 **메모리에 할당**된다.

- 인스턴스는 객체에 포함되어있다.
- `instanceof` 예약어를 사용하여 현재 참조형 변수가 객체주소를 참조하고 있는지 확인할때 사용하는 연산자이다.

[[🔝위로가기]](#)

<br>

> ## 오버라이딩(Override)와 오버로딩(Overloading)

[[🔝위로가기]](#)

<br>

> ## 운영체제(Operating System)

[[🔝위로가기]](#)

<br>

> ## Restful API

> ### REST API

- 웹(HTTP)의 장점을 활용한 아키텍쳐를 의미한다.

- REST는 `GET` , `POST`, `PUT`, `DELETE` 가 있다.
- 특징

  - 1. HTTP 표준만 맞다면 어떤 기술도 가능한 인터페이스 스타일을 갖고있다.
    - 특정언어나 기술에 종속받지 않고 모든 플랫폼에서 사용이 가능하다.
  - 2. Statelessness
    - HTTP Session(HTTPS)와 같은 컨텍스트 저장소에 상태정보를 저장하지 않는다.
    - **Request**만 Message로 처리하면된다. 컨텍스트 정보를 신경쓰지 않아도 되므로 구현이 단순해진다.
  - 3. Resource 지향 아키텍쳐(ROA, Resource Oriented Architecture)
  - 4. Cleint - Server Architecture
  - 5. Cache Ability
  - 6. Layered System
  - 7. Code on Demand

- 참고자료
  - https://github.com/gyoogle/tech-interview-for-developer/blob/master/Web/%5BWeb%5D%20REST%20API.md

[[🔝위로가기]](#)

<br>

> ## 라이브러리와 프레임워크의 차이점?

> ### 라이브러리 (도구)

- 프로그램 기능을 수행하기 위해서 활용 가능한 도구들의 집합니다.
- 특정 기능에 대한 도구 또는 **함수들의 집합**이다.

<br>

> ### 프레임워크 (집)

- 스프링 프레임워크는 자바플래폼을 위한 오픈소스 애플리케이션 프레임워크이다.
- DI (Dependency Injection) 의존성 주입
  - 설정파일이나 Annotation을 통해 객체간의 의존관계를 설정하여 **개발자가 직접 객체를 생성할 필요가 없다.**
- IoC (Inversion of Control) 제어의 반전
  - 프레임워크는 객체의 생성부터 소멸까지 모든 생명주기를 관리한다.
  - 객체를 직접 생성/ 호출하지 않고 만들어둔 자원을 호출하여 사용한다.
- AOP
  - 트랜잭션, 로깅, 보안에서 사용한다.

> ### 프레임워크와 라이브러리의 차이점

- 프레임워크는 전체적인 흐름을 자체적으로 가지고 있다.

  - 프로그래머는 그 안에서 필요한 코드를 작성한다.

- 라이브러리는 프로그래머가 전체적인 흐름을 가지고 있어, 라이브러리를 자신이 원하는 기능을 구현하고 싶을 때 가져다 사용할 수 있다.

- 참고자료
  - https://juyeop.tistory.com/23

<br>

[[🔝위로가기]](#)

<br>

> ## DevOps 란?

[[🔝위로가기]](#)

<br>

> ## AWS, GCP 클라우드

[[🔝위로가기]](#)

<br>

> ## HTTP 프로토콜이란?

- ### HTTP (HyperText Transfer Protocol)

  - **인터넷 상에서 클라이언트와 서버가 자원을 주고 받을 때 쓰는 통신 규약**
  - Hyper Text의 전송을 목적으로 설계된 Application 레벨의 프로토콜
  - 텍스트 교환
  - **Hyper Text** : 클라이언트의 선택에 따라서 이동이 가능한 조직화된 정보
    - 이동이 가능한 텍스트를 의미한다.
  - Serverless 프로토콜
    - 서버는 클라이언트의 상태정보를 유지하지 않는다.
    - 클라이언트가 다시 요청을 해도 이 클라이언트가 조금전에 한차례 요청을 했던 클라이언트임을 인식하지 못한다.

- ### HTTPS(HypterText Transfer Protocol Secure) 는 보완기능까지 추가되어있다.
  - 중간에 가로채는 경우를 막기위해서.
  - 텍스트를 암호화 시킨다.
  - `주의 요함` , `안전하지 않은 사이트` 와 같은 알림으로 주의를 받는다.

[[🔝위로가기]](#)

<br>

> ## GET과 POST방식

> ### GET 방식

- 요청을 전송할 때 필요한 데이터를 body에 담지않고 **쿼리스트링을 통해 전송한다.**
- 불필요한 요청을 제한하기 위해서 요청이 캐시될 수 있다.
- **URL에 전송되는 데이터가 노출**된다.
- 동일한 서버 요청을 여러번 전송하면 동일한 응답이 돌아온다.

<br>

> ### POST 방식

- 리소스를 생성/변경하기 위해 설계되어있기 때문에 전송해야될 데이터를 **HTTP 메시지의 Body에 담아서 전송**한다.
- 전송해야할 데이터를 URL에 노출하지 않는다.
- 민감한 데이터의 경우에는 암호화를 이용해서 전송해야한다.
- POST는 즐겨찾기나 캐싱이 불가능하다.
- 동일한 요청을 여러번 전송해도 응답이 달라질 수 있다.

[[🔝위로가기]](#)

<br>

> ## Stack과 Queue 정의

- ### Stack

  - **후입선출 (Last In First Out)**
  - 먼저 들어간 요소가 맨 나중에 나오는 구조로 되어있다.
  - 맨나중에 들어간 요소가 맨처음으로 나올 수있도록 함.

- ### Queue
  - **선입선출 (First In Last Out)**
  - 먼저 들어간 요소가 먼저 나오는 구조로 되어있다.

[[🔝위로가기]](#)

<br>

> ## 인덱스(INDEX)

- 인덱스는 데이터레코드를 빠르게 접근하기 위해 `<key값, 포인터>` 쌍으로 구성되는 데이터 구조이다.
- 데이터가 저장된 물리적 구조와 밀접한 관계가 있다.
- 인덱스는 레코드가 저장된 물리적 구조에 접근하는 방법을 제공한다.

- 인덱스(INDEX) 가 필요한 이유?
  - 대용량 데이터가 담긴 테이블에서 원하는 데이터를 빠르게 찾을 수 있다.
- 인덱스의 장점

  - 검색속도가 매우 빠르다.
  - 해당 쿼리의 부하가 줄어들어, 시스템 성능이 향상된다.

- 인덱스의 단점

  - 인덱스가 데이터베이스 공간에 차지해서 추가적인 공간이 필요하다.
  - 인덱스를 생성하는데 시간이 오래걸린다.
  - 데이터베이스 변경작업(INSERT, UPDATE, DELETE)가 자주 일어날 경우에는 오히려 성능이 많이 나빠질 수 있다.

- 인덱스의 종류

> ### B-Tree (Balanced Tree, 균형트리)

- 균형잡힌 트리이다.
- 주로 인덱스를 표현할 때와 그 이외에 많이 사용된다.
- B-Tree구조는 데이터를 검색(SELECT)할때 뛰어난 성능을 보인다.

- ### 페이지(Page)
  - 16Kbyte 크기의 최소한의 저장단위이다.
  - 아무리 작은 데이터 한개를 저장하더라도 한개 페이지 16Kbyte를 차지한다.
  - MySQL에서는 노드가 페이지가 되며, 인덱스를 구현할 때 사용된다.

<br>

> ### Node

- 노드란, 트리 구조에서 데이터가 존재하는 공간을 의미한다.

[[🔝위로가기]](#)

> ## TCP 와 UDP

> ### TCP(Transmission Control Protocol)

- 인터넷상에서 데이터를 메시지의 형태로 보내기 위해 IP와 함께 사용하는 프로토콜

- **신뢰성있는 데이터전송** 을 지원하는 **연결지향형** 프로토콜 이다.
- 데이터전송에 신뢰성을 위해 `데이터 세그먼트` 단위로 분할한다.
- 전송속도를 조정하며 **데이터가 제대로 전달 되지 않았을 경우 재전송**을 요청한다.

- UDP에 비해 속도가 느리다.
- 흐름제어와 혼잡제어를 지원하여 데이터의 순서를 보장한다.

  - 흐름제어
  - 혼잡제어

- 참고자료: https://github.com/HyeminNoh/Tech-Stack/blob/master/docs/Network/TCP_and_UDP.md

<br>

> ### UDP

[[🔝위로가기]](#)

<br><br>

> ## 힙(heap)과 스택(stack)

> ### Heap

- 동적할당할 때 사용
- 새로운 객체를 생성할 때 `new()`
- C언어에서는 `malloc()`을 사용하여 참조변수에 주소를 담아서 객체를 불러온다.

> ### Stack

- 지역변수, 매개변수, 리턴값(임시 메모리 영역)에 사용된다.
- 스레드는 stack만 따로 할당받고 나머지 영역은 서로 공유한다.

- 프로세스는 별도의 주소공간을 할당한다.

[[🔝위로가기]](#)

<br>

> ## 해시테이블(Hash Table)

> ### Hash는 무엇인가?

- 데이터를 효율적으로 관리하기 위해, 임의의 길이 데이터를 고정된 길이 데이터로 매핑하는 것을 의미한다.
- 해시 함수는 키값을 입력으로 받아 해시 테이블 상의 주소를 리턴한다.

<br>

![](./img1/hash.png)

<br>

- 데이터가 많아지면, 다른데이터가 같은 해시값으로 충돌나는 현상이 발생한다!
- 이러한 충돌문제를 해결하기 위해서
  - Chaining : 연결리스트로 노드를 계속 추가해나가는 방식 (제한없이 계속 연결은 가능하나 메모리 문제가 발생한다.)
  - Open Addressing : 해시함수로 얻은 주소가 아닌 다른 주소에 데이터를 저장할 수 있도록 허용
  - 선형탐사 : 정해진 고정폭으로 옮겨 해시값의 중복을 피함
  - 제곱탐사 : 정해진 고정폭을 제곱수로 옮겨 해시값의 중복을 피함

> ### Hash Table

- 해시테이블을 사용하는 이유는?

  - 적은 자원으로 많은 데이터를 효율적으로 관리할 수 있다.
  - 하드디스크나 클라우드에 존재하는 무한한 데이터들을 유한한 개수의 해시값으로 매핑하면, 작은 메모리로도 프로세스 관리가 가능하다.
  - 언제나 동일한 해시값을 리턴한다. 인덱스를 알면 빠른 데이터검색이 가능해진다.
  - 해시테이블의 시간복잡도는 O(1) 이다.
    - 왜 해시테이블의 복잡도가 O(1)일까?
      - 여러개의 키값이 존재할텐데, 키값들을 검색하려면 O(N)일텐데 왜 하필 O(1)일까?
      - 내부적으로 배열 버킷을 사용하여 데이터를 저장한다.
      - 해시테이블은 각각의 키값에 해시함수를 적용해 배열의 고유한 인덱스를 생성하고, 이 인덱스를 활용해 값을 저장하거나 검색한다.

- Java HashMap과 HashTable의 차이 ==> 동기화 지원여부

[[🔝위로가기]](#)

<br>

> ## N:N 테이블

[[🔝위로가기]](#)

<br>

> ## 이분탐색(Binary Search)

[[🔝위로가기]](#)

<br><br>

> ## 인터페이스(Interface)와 상속

> ### 인터페이스

- 자바에서 인터페이스는 객체의 사용방법을 정의한 타입이다.
- 인터페이스는 객체의 교환성을 높여주기 때문에 다형성을 구현하는 매우 중요한 역할을 한다.
- 인터페이스는 **상수**와 **메소드**만을 구성멤버로 갖는다.
- **인터페이스는 new() 연산자를 이용해서 직접 객체를 생성할 수 없다.**
- 인터페이스의 메소드는 실행블록이 없는(몸체가 없는) 추상메소드로 선언이 가능하다.
  - java8이후로부터는 default메소드와 정적메소드 선언이 가능하다.

<br>

- 인터페이스의 특징

  - 모든 인터페이스의 메소드는 묵시적으로 public이고 abstract이다 (즉, 추상메소드로 구성되어있다.)
  - 변수는 묵시적으로 public static final(즉, 상수를 갖는다.)
  - 객체 생성은 안되나 참조형 변수로는 가능하다.
    - 익명객체를 생성할 수 있으나, 추상메소드(실행블록이 없는 메소드)들의 실체메소드(몸체가 있는/ 실행블록이 있는 메소드)를 작성해야한다.

- 인터페이스의 장점
  - 상위 타입 역할로 다형성을 지원하여 연결한다.
  - 해당 객체가 다양한 기능 제공시에도 인터페이스에 해당하는 기능만을 사용하게 제한이 가능하다.
  - 공통 기능상의 일관성을 제공한다.

<br>

> ### 추상클래스

- 추상은 **실체간의 공통적인 특성**을 갖는다.
- 추상클래스와 실체클래스는 상속관계를 갖는다(부모: 추상/ 자식: 실체)

  - 실체클래스는 추상클래스의 모든 특성을 물려받는다. 이외의 추가적인 특성을 가질 수 있다.
  - 추상클래스는 새로운 실체 클래스를 만들기 위해 부모클래스로만 사용된다.
  - 실체클래스에 `extends` 예약어를 붙여야 추상클래스의 자식클래스임을 나타낸다.

- 추상클래스를 사용하는 이유

  - 실체클래스들의 공통된 필드나 메소드의 이름을 통일시킨다.
  - 실체클래스를 작성할 때 시간을 절약한다.

- 추상클래스는 `abstract` 키워드를 붙여서 선언해야한다.
- `new`연산자를 이용해서 객체를 직접 만들지는 못하고
- 상속을 통해서 자식클래스에서 만들 수 있다.

<br>

> ### 인터페이스와 추상클래스의 차이점?

- **클래스(추상클래스)는 단일 상속이 가능**하다.(부모가 1개)
- **인터페이스는 다중상속이 가능하다.** (부모가 여러개)

<br>

- 추상클래스는 필드, 메소드(몸체가 없는 메소드), 상수 로 구성되어있다.
- 인터페이스는 상수와 메소드로 구성되어있다.
- 반면 인터페이스는 **생성자를 갖지 않아서 객체를 만들 수 없다.**
  - 상속은 자식클래스의 생성자를 호출할때 먼저 부모객체를 만들어낸다.

[[🔝위로가기]](#)

<br>

> ## 싱글톤 패턴(singleton)

- 애플리케이션에서 시작될때 어떤 클래스가 최초 한번만 메모리를 할당(static)하고 해당 메모리에 인스턴스를 만들어서 사용하는 패턴이다.
- **싱글톤 패턴은 하나의 인스턴스를 생성**하는 디자인 패턴이다.
- 생성자가 여러번 호출되도 실제로 생성되는 객체는 하나이며
- (추가질문) 파이썬에서는 싱글톤 패턴을 나타낼 수 있을까?

- 왜 싱글톤 패턴을 쓰나요?

  - 객체를 생성할 때마다 메모리 영역을 할당 받아야한다.
  - 한번의 new를 통해 객체를 생성한다면 메모리 낭비를 방지할 수 있다.
  - 싱글톤으로 구현한 인스턴스는 '전역'이므로 다른 클래스들의 인스턴스들이 데이터를 공유하는 것이 가능한 장점이 있다.

- 언제 싱글톤 패턴을 쓰나요?

  - 주로 공통된 객체를 여러개 생성해서 사용해야하는 상황
    - 데이터베이스에서 커넥션풀, 스레드풀, 캐시, 로그 기록 객체

- 단점은 무엇인가요?

  - 싱글톤 인스턴스가 혼자 너무 많은 일을 하거나, 많은 데이터를 공유시키면 다른 클래스들간의 결합도가 높아지게된다.
    - 이는 개방 폐쇠 원칙이 위배된다.
  - 결합도가 높아지게되면 유지보수가 힘들고 테스트도 원활하게 진행할 수 없는 문제점이 발생한다.
  - 멀티스레드 환경에서 동기화 처리를 하지 않았을 때 인스턴스가 2개 생성되는 문제도 발생할 수 있다.

- 참고자료
  - https://github.com/gyoogle/tech-interview-for-developer/blob/master/Design%20Pattern/Singleton%20Pattern.md
  - https://github.com/gyoogle/tech-interview-for-developer/blob/master/Design%20Pattern/Singleton%20Pattern.md

[[🔝위로가기]](#)

<br>

> ## URL Encoding

URL Encoding을 하는 이유와 그 방법을 서술하시오.

- (1) URL Encoding을 하는 이유: URL은 ASCII코드로 이뤄져있습니다.

- (2) URL Encoding 방법: ASCII문자 이외의 문자는 "%"와 16진수 문자를 조합해서 Encoding을 합니다.

[[🔝위로가기]](#)

<br>

> ## 옵져버 패턴(Observer)

- Observer 패턴은 하나의 관찰대상 - 여러개의 관찰자 구조가 필요할 때 사용되는 패턴
- Observer 패턴은 상태를 가지고 있는 주체 객체와 상태의 변경을 알아야하는 관찰 객체가 있다.
- 1:1 관계 or 1:N 관계이다.
- 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들에게 연락이 가고, 자동으로 정보가 갱신되는 1:N관계를 정의한다.

- 서로의 정보를 주고받는 과정에서 정보의 단위가 클수록, 객체들의 규모가 클수록 복잡성이 증가된다.

![](./img1/observer.png)

- Subject

  - 관찰 대상이 되는 객체
  - 자신을 관찰하는 옵져버 리스트를 가지고 관리를 한다.
  - 옵져버 붙이기(attach), 떼기(detach), 알리기(notify)를 갖고 있다.

- Observer

  - Subject를 관찰하는 객체이다.
  - Subject가 notify를 호출하면 Observer의 update도 호출된다.

- 참고자료
  - https://dailyheumsi.tistory.com/211?category=855210

<br>

> ## 구조 패턴 프록시(Proxy)

- 프록시 패턴은 프록시 객체를 통해 기본객체에 접근하는 패턴이다.

![](./img1/proxy.png)

- 장점

  - 객체의 리소스가 무거운 경우 프록시 객체에서 간단한 처리를 하거나, 기본 객체를 캐싱처리함으로써 부하를 줄일 수 있다.
  - 기본 객체에 대한 수정없이 클라이언트에서ㅢ 사용과 기본 객체 사이에 일련된 로직을 프록시 객체를 통해 넣을 수 있다.
  - 프록시는 기본 객체와 요청사이에 있기 때문에 일종의 방패(보안)의 역할을 한다.
  - 구조나 코드 구현이 간단하다.

- 단점

  - 프록시 객체가 중간에 끼어있어서 간혹 응답이 느려질 수 있다.
  - 캐싱이 안되어있는 초기 사용의 경우가 그렇다.

- 활용상황

  - 기본 객체가 리소스 집약적인 경우. 자잘한 작업들은 프록시 객체가 처리하게 한다.
  - 기본 객체에 접근을 제어해야하는 경우. 프록시 객체가 권한에 따라 접근 로직을 다르게 처리하게 한다.

- 참고자료
  - https://dailyheumsi.tistory.com/201?category=855210
