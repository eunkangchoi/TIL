# 기술면접 대비 - 기본기 정리

<details>
  <summary>빠르게 보기</summary>

- [:pencil2: No SQL vs SQL](#nosql-과-sql-차이점)
- [:pencil2: Process vs Thread](#프로세스와-스레드)
- [:pencil2: Multip Process vs Multi Thread](#멀티프로세스와-멀티스레드)
- [:pencil2: Cache](#캐시cache)
- [:pencil2: Docker](#docker의-정의)
- [:pencil2: Kubernetes](#쿠버네티스-정의)
- [:pencil2: JWT](#jwt)
- [:pencil2: Agile ](#agile-방법론)
- [:pencil2: Transaction](#트랜잭선transaction-정의)
- [:pencil2: 객체지향 프로그래밍(OOP)](#객체지향-프로그래밍-정의)
- [:pencil2: 클리스/객체/인스턴스 ](#클래스--객체--인스턴스)
- [:pencil2: Override vs Overload](#오버라이딩override와-오버로딩overloading)
- [:pencil2: OS](#운영체제operating-system)
- [:pencil2: REST](#restful-api)
- [:pencil2: Library vs Framework](#라이브러리와-프레임워크의-차이점)
- [:pencil2: DevOps](#devops-란)
- [:pencil2: Cloud](#aws-gcp-클라우드)
- [:pencil2: HTTP & HTTPS](#http-프로토콜이란)
- [:pencil2: GET vs POST](#get과-post방식)
- [:pencil2: Stack vs Queue](#stack과-queue의-정의)
- [:pencil2: Database - Index ](#인덱스index)
- [:pencil2:](#tcp-와-udp)
- [:pencil2:](#)
- [:pencil2:](#)
- [:pencil2:](#)

</details>

<br><br>

> ## NoSQL 과 SQL 차이점?

![](./img1/ex1.png)

### SQL (Structured Query Language)

- 관계형 데이터베이스
- 데이터의 형식이 구조화되어있다.
- 스키마에 따라 데이터베이스 테이블에 저장된다.
  - _스키마 (scheme)_
    - 데이터 구조와 제약조건에 관한 전반적인 명세를 기술한 메타데이터의 집합
    - 데이터베이스를 구성하는 개체(Entity), 속성(Attribute), 관계(Relationship) 및 데이터 조작시 데이터 값들이 갖는 제약조건등에 관해 전반적으로 정의한다.
  - Attribute(속성) : 개체의 특성을 나타냄(컬럼)
  - Entity(개체) : 속성들의 집합을 의미한다.

- 데이터 구조가 매우 엄격하다.
- 데이터의 일관성을 보증한다.
- 정규화에 따른 갱신비용을 최소화 한다.
- 시스템복잡도를 고려하여 구조화 해야한다.
- 행과 열로 구성되어있고, 엑셀시트처럼 2차원 배열 형태로 형식이 정해져있다.
- 데이터에서 어떤 데이터를 얻을지에 대한것은 편함. (**컬럼을 통해서 데이터를 쉽게 얻을 수 있다.**)

<br>

### No SQL (Not Only SQL)

No SQL은 세종류가 존재한다.

- 데이터간의 관계를 정의하지 않는다.
  - 반대로, sql은 데이터간의 관계를 정의한다.
- collection 이라는 형태로 데이터를 관리한다.
- 대용량 데이터를 저장할 수 있다.
- 분산형 구조
- 유연한 데이터 모델링
- 수평적 확장이 쉽다 (컬럼추가와 같은 것들)
- 컬렉션에 중복된 데이터가 저장이 될 수 있다.

<br><br>

- ### **Document DB**
  - **Mongo DB**가 대표적이다.
  - **데이터를 JSON 형태로 저장**한다.
  - 형태가 구조화되어있지 않아서 어떤 형태로든지 저장이 가능하다.

![](./img1/ex2.png)

<br>

- ### **Key Value DB**

  - **Cassandra DB**와 **Dynamo DB**가 대표적이다.

  - #### **Cassandra DB**

    - column wide database
    - **읽기, 쓰기 가 겁나 빠르다.**
    - **많은 양의 데이터를 빠르게 저장하고 읽을 수 있다.**
    - 많은양의 데이터를 빨리 읽어야되는 *검색 엔진*에 많이 쓰인다.

  - #### **Dynamo DB**
    - 아마존에서 만든 데이터베이스
    - 서버리스(serverless) key value database
    - 매초에 2400000개를 읽는다.
    - 저장하기전에 db에 무엇을 얻을 것인지를 미리 생각해야됨.

- ### **Graph DB**
  - column과 document가 필요없을 때
  - 각각의 entity를 저장하고 이를 관계망으로 연결하는 것.
  - 각노드 간의 관계를 알 때 필요하다.
  - 페이스북이 graph db를 사용. (tao)
  - 유저 1이 좋아요를 누르면 => 유저1의 친구에게 공유할 수 있다.

![](./img1/ex3.png)

<br>

- 참고
  - https://www.youtube.com/watch?v=Q_9cFgzZr8Q
  - https://www.youtube.com/watch?v=z9chRlD1tec
  - https://github.com/HyeminNoh/Tech-Stack/blob/master/docs/Database/RDBMS_and_NoSQL.md

[[🔝위로가기]](#)

<br>

> ## 프로세스와 스레드

> ### 프로세스 (process)

- 1. 정의
  - 어떤 작업을 위해 **실행할 수 있는 파일**
  - **프로그램을 메모리 상에서 실행중인 작업**
  - 메모리에 올라와 실행되고 있는 프로그램의 인스턴스
  - 운영체제로부터 시스템 자원을 할당받는 작업의 단위
    - 시스템 자원
      - CPU 시간
      - 주소 공간
      - 메모리 영역
  - 실행된 프로그램
- 2. 특징
  - 프로세스는 각각 독립된 메모리 영역(code, data, stack, heap)을 할당 받는다.
  - 프로세스 당 최소 1개의 스레드(main thread)를 갖는다.
  - 각 프로세스는 별도의 주소공간에서 실행된다.
  - 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없다.
  - 한 프로세스가 다른프로세스 자원에 접근하려면 프로세스간의 통신(IPC, Inter-Process Communication)을 사용해야한다.
    - 예) 파이프, 파일, 소켓 등을 이용한 통신 방법

<br>

> ### 스레드 (Thread)

- 1. 정의
  - 프로세스 안에서 실행되는 여러흐름 단위
  - 프로세스의 특정한 수행 경로
  - 프로세스가 할당받은 자원을 이용하는 실행의 단위
  - 스레드는 프로세스 내에서 각각 stack만 할당 받는다.
    - code, data, heap영역은 공유한다.
  - 프로세스 내의 주소 공간이나 자원들(힙공간)을 같은 프로세스 내에서 스레드끼리 공유하면서 실행된다.
  - 같은 프로세스 안에 있는 여러 스레드들은 같은 힙공간을 공유한다.
  - 프로세스는 다른 프로세스의 메모리에 직접 접근할 수 없다.
  - 각 스레드들은 별도의 레지스터와 스택을 갖는다.
  - 힙메모리는 서로 읽고 쓸 수 있다.
  - 한 스레드가 프로세스 자원을 변경하면, 다른 이웃 스레드도 그 변경 결과를 즉시 볼 수 있다.

<br>

- 참고 자료
  - https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html

[[🔝위로가기]](#)

<br>

> ## 멀티프로세스와 멀티스레드

> ### 1. 멀티 프로세스

- 멀티프로세싱(multi processing)

  - 정의

    - 하나의 응용프로그램을 여러개의 프로세스로 구성한다.
    - 각 프로세스가 하나의 작업(task)을 처리하도록 한다.

  - 장점
    - 여러개의 자식 프로세스 중 하나에 문제가 발생하면, 그 자식 프로세스만 죽고 다른 프로세스에게 영향을 주지 않는다.
  - 단점

    - 1. `context switching`에서의 오버헤드가 발생한다.
      - 캐시 메모리 초기화등 무거운 작업이 진행되고 많은 시간이 소모되는 오버헤드가 발생한다.
      - 프로세스는 각각의 독립된 메모리 영역을 할당받기 때문에 프로세스 사이에서 공유하는 메모리가 없다.
      - `context switching`이 발생하면 캐시에 있는 모든 데이터를 리셋하고 다시 캐시정보를 불러와야한다.
    - 2. 프로세스 사이의 어렵고 복잡한 통신기법

      - 프로세스는 각각의 독립된 메모리영역을 할당 받기 때문에, 하나의 프로개름에 속하는 프로세스들 사이의 변수를 공유할 수 없다.

    - (참고) _`Context Switching`_?
      - CPU에서 여러 프로세스를돌아가면서 작업을 처리한다.
      - 동작중인 프로세스가 대기를 하면서 해당 프로세스의 상태(context)를 보관하고, 대기하고 있던 다음 순서의 프로세스가 동작하면서 이전에 보관했던 프로세스의 상태를 복구하는 작업을 의미한다.

<br><br>

> ### 2. 멀티 스레드

- 멀티 스레딩(multi threading)

  - 정의

    - **하나의 응용프로그램을 여러개의 스레드**로 구성하고, 각 스레드로 하여금 하나의 작업을 처리하도록 하는 것이다.
    - 윈도우 리눅스 등 많은 운영체제들이 멀티프로세싱을 지원하고 있지만 멀티스레딩을 기본으로 하고있다.
    - 웹서버는 대표적인 멀티 스레드 응용프로그램이다.

  - 장점
    - 시스템 자원 소모 감소 (자원의 효율성 증대)
      - 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있다.
    - 시스템 처리량 증가 (처리비용 감소)
      - 스레드 간 데이터를 주고받는 것이 간단하다
      - 시스템 자원 소모가 줄어든다.
    - 간단한 통신방법으로 인한 프로그램 응답 시간 단축
      - 스레드는 프로세스 내의 stack영역을 제외한 모든 메모리를 공유하기 때문에 통신부담이 적다.
  - 단점
    - 주의 깊은 설계가 필요하다.
    - 디버깅이 까다롭다.
    - 단일 프로세스 시스템의 경우 효과를 기대하기 어렵다.
    - 다른 프로세스에서 스레드를 제어할 수 없다.
      - 프로세스 밖에서 스레드 각각을 제어할 수 없다.
    - 멀티 스레드의 경우 자원 공유의 문제가 발생한다(동기화 문제)
      - 동기화
      - 스레드 간의 자원 공유는 전역변수(데이터 세그먼트)를 이용하므로 함께 상용할 때 충돌이 발생할 수 있다.
    - 하나의 스레드에 문제가 발생하면 전체 프로세스가 영향을 받는다.

<br><br>

> ### 멀티 프로세스 대신에 멀티스레드를 사용하는 이유는?

- #### 프로그램을 여러개 켜는 것보다, 하나의 프로그램 안에서 여러 작업을 해결한다.

- #### 자원의 효율성 증대

  - 멀티프로세스로 실행되는 작업을 멀티 스레드로 실행할 경우, **프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어**들기 때문에 자원을 효율적으로 관리할 수 있다.

  - 프로세스간의 context switching시 단순히 cpu레지스터 교체뿐만 아니라 RAM과 CPU 사이의 캐시 메모리에 대한 데이터까지 초기화되므로 오버헤드가 크기 때문이다.

  - 스레드는 프로세스 내의 메모리를 공유하기 때문에 독립적인 프로세스와 달리 스레드간 데이터를 주고받는 것이 간단해지고 시스템 자원 소모가 줄어들게 된다.

- #### 처리 비용 감소 및 응답 시간 단축

  - 프로세스 간의 통신(IPC)보다 스레드간의 통신의 비용이 적으므로 작업들 간의 통신의 부담이 줄어든다.
  - 스레드는 stack영역을 제외한 모든 메모리를 공유한다.
  - 프로세스 간의 전환 속도보다 스레드간의 전환 속도가 빠르다.
  - context switching시 스레드는 stack영역만을 처리한다.

- 참고자료
  - https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html

[[🔝위로가기]](#)

<br>

> ## 캐시(Cache)

- Cache

<br>

> ## Docker의 정의

- Docker은 `environment disparity` 문제를 해결한다.

  - environment disparity란?
    - 개발한 것을 서버에 올렸는데, 서버에 올리니까 안됨.
    - OS에 따라 생성

- Docker is a standalone software that can be installed on any computer to run containerized applications.
  - Docker은 컴퓨터의 OS상관없이 컨테이너화된 어플리케이션들을 설치할 수 있는 독립적인 소프트웨어

- Containerization
  - Containerization is an approach of running applications on an OS such that the application is isolated from the rest of the system.
  - 컨테이너화는 애플리케이션이 시스템의 나머지 부분과 분리되도록 os에서 애플리케이션을 실행하는 접근 방식이다.

- Docker is what enables us to run, create and manage containers on a single operating system.
  - Docker은 단일 OS에서 컨테이너들을 실행, 생성 및 관리 할 수 있도록 지원한다.


- 참고자료
  - https://containerjournal.com/topics/container-ecosystems/kubernetes-vs-docker-a-primer/


[[🔝위로가기]](#)

<br>

> ## 쿠버네티스 정의


- If you have Docker installed on a bunch of hosts(different operating system), you can leverage Kubernetes.
  - 여러 호스트(다른 운영체제)에 Docker가 설치되어있는 경우 Kubernetes를 활용할 수 있다.

- Kubernetes can then allow you to automate container provisioning, networking, load-balancing, security and scaling across all these nodes from a single command line or dashboard.
  - Kubernetes는 대시보드의 한 개명령어로부터 모든노드들에 걸쳐서 컨테이너를 권한설정(provisioning), 네트워킹, 부하균형(로드 밸런싱, load-balancing), 보안 및 확장을 자동화 해줄 수 있다.

- A collection of nodes that is managed by a single Kubernetes instance is referred to as Kubernetes Cluster
  - 단일 Kubernetes 인스턴스로부터 관리되는 노드의 집합체들은 Kubernetes Cluster라고 불린다.

[[🔝위로가기]](#)

<br>

> ## JWT



[[🔝위로가기]](#)

<br>

> ## 쿠키(Cookie)와 세션(Session)

- 정리
  - 쿠키(cookie)
    - **사용자 컴퓨터에 저장**
    - 저장된 정보를 다른 사람 또는 시스템이 볼 수 있다.
    - 유효시간이 지나면 사라진다.
  - 세션(session)
    - **서버에 저장된다.**
    - 서버나 브라우저가 종료되거나, 유효시간이 지나면 사라진다.
    - 보안에 좋다.

<br>

- ### 쿠키 동작 과정

![](./img1/e1.png)

![](./img1/e2.png)

<br>

- 왜 쿠키(cookie)와 세션(session)을 사용하나?

  - http 프로토콜은 connectionless, stateless한 특성을 갖고있다.
  - 비연결성(connectionless) : 클라이언트가 서버에 요청을 한 후 응답을 받으면 **맺었던 연결을 끊는 특성**
  - 무상태성(stateless) : 서버와 클라이언트 사이의 통신이 끝나면 **상태를 유지하지 않는 특성**

<br>

- 상태를 모르면...아래와 같이 **클라이언트가 누군지 확인하기 위해서 인증을 반복**해야된다. 이는 HTTP 프로토콜 특성으로 인한 단점이라서 `쿠키`와 `세션`이 필요하다.

```
쇼핑몰에 접속
로그인
상품클릭 -> 상세화면 이동
로그인
주문
로그인
...
```

- ### 쿠키(Cookie)
  - **클라이언트의 상태정보를 로컬에 저장한 key-value형식의 데이터 파일**
  - 클라이언트 정보파일을 브라우저에 저장한다.
  - **클라이언트 로컬에 저장되는 키와 값**이 들어있는 작은 데이터 파일
  - 사용자 인증이 유효한 시간을 명시할 수 있다.
    - 유효시간이 정해지면 브라우저가 종료되어도 인증이 유지된다.
  - **클라이언트의 상태 정보를 로컬에 저장했다가 참조한다.**
  - Response Header에 Set-cookie 속성을 사용하면 클라이언트에 쿠키를 만들 수 있다.
  - 쿠키는 사용자가 따로 요청하지 않아도, 브라우저가 Request시 Request Header를 넣어서 자동으로 서버에 전송한다.
  - 쿠키의 구성요소
    - 이름(key): 쿠키를 구별하는데 사용하는 이름
    - 값(value): 쿠키의 이름과 관련된 값
    - 유효시간: 쿠키의 유지시간
    - 도메인 : 쿠키를 전송할 도메인
    - 경로: 쿠키를 전송할 요청경로

<br>

- ### 세션(Session)

  - 쿠키를 기반하고 있다.
  - 세션(Session)은 서버 측에서 관리하고 있다.
  - **클라이언트를 구분하기 위해 세션 id를 부여**한다.

    - session id : 클라이언트가 Request를 보내면 해당서버의 엔진이 클라이언트에게 유일한 id를 부여한다.

  - **웹브라우저가 서버에 접속해서 브라우저가 종료할 때까지 인증상태를 유지**한다.
  - 동시 접속자 수가 많은 경우에는 서버메모리에 여러사용자의 정보를 저장해야되므로 서버에 과부하가 발생하여 성능저하가 생길 수 있다.
  - 특징
    - 세션 ID로 클라이언트를 구분해서 클라이언트의 요구에 맞는 서비스를 제공한다.
    - 쿠키보다 보안면에서 우수하다.

<br>

- ### 세션 동작과정

![](./img1/s1.png)

![](./img1/s2.png)

<br>

> ### 쿠키와 세션은 어떤 차이점을 갖는가?

- 1. 서버의 자원을 사용하는가?

  - 쿠키는 서버의 자원을 전혀 사용하지 않는다.
  - 세션은 서버의 자원을 사용한다.

- 2. 보안

  - 세션은 쿠키보다 보안면에서 우수하다.
  - 쿠키는 세션보다 요청속도가 빠르다.
    - 세션은 서버의 처리가 필요하다.
  - 쿠키는 클라이언트 로컬에 저장되기때문에 변질되거나 request에서 sniffing을 당할 우려가 있어서 보안에 취약하다.
  - 반면, 세션은 쿠키를 이용해서 session id만 저장하고 id로 구분하여 서버에서 처리하기때문에 보안성이 좋다.

- 3. 만료시간
  - 쿠키는 파일로 저장되기때문에 브라우저를 종료해도 (유효시간이 지나지 않으면) 정보가 남아있다.
  - 세션은 만료시간을 정할 수있지만, 브라우저가 종료되면 만료시간 상관없이 삭제된다.
  - 세션의 정보는 서버에서 처리를 하기때문에 쿠키보다 속도가 느리다.

[[🔝위로가기]](#)

<br>

> ## 배열과 리스트(Linked List)는 어떤차이점을 갖는가?

[[🔝위로가기]](#)

<br>

> ## Agile 방법론

[[🔝위로가기]](#)

<br>

> ## 트랜잭션(Transaction) 정의

- 데이터베이스의 논리적인 기능을 수행하기 위한 일련의 연산집합이며, **작업의 단위**이다.

- 트랜잭션은 데이터베이스 관리 시스템에서 회복 및 병행제어 시에 처리되는 **작업의 논리적인 단위**이다.

- 데이터베이스의 일관성(consistency) 상태를 갖는다.

[[🔝위로가기]](#)

<br>

> ## 객체지향 프로그래밍 정의

> ### 다형성

[[🔝위로가기]](#)

<br>

> ## 클래스 / 객체 / 인스턴스

> ### 클래스(class)

- 객체를 만들어 내기위한 설계도(틀)
- 연관되어있는 변수와 메소드의 집합

<br>

> ### 객체(Object)

- 소프트웨어 세계에 구현할 대상
- 클래스에 선언된 모양 그대로 생성된 실체

- 클래스의 인스턴스라고 불린다.
- 객체는 모든 인스턴스를 대표하는 포괄적인 의미를 갖는다.

<br>

> ### 인스턴스(Instance)

- 설계도를 바탕으로 소프트웨어 세계에 구현된 구체적인 실체

  - 객체를 소프트웨어에 실체화한 것.
  - 실체화된 인스턴스는 **메모리에 할당**된다.

- 인스턴스는 객체에 포함되어있다.

[[🔝위로가기]](#)

<br>

> ## 오버라이딩(Override)와 오버로딩(Overloading)

[[🔝위로가기]](#)

<br>

> ## 운영체제(Operating System)

[[🔝위로가기]](#)

<br>

> ## Restful API

[[🔝위로가기]](#)

<br>

> ## 라이브러리와 프레임워크의 차이점?

[[🔝위로가기]](#)

<br>

> ## DevOps 란?

[[🔝위로가기]](#)

<br>


> ## AWS, GCP 클라우드

[[🔝위로가기]](#)

<br>

> ## HTTP 프로토콜이란?

- ### HTTP (HyperText Transfer Protocol)

  - **인터넷 상에서 클라이언트와 서버가 자원을 주고 받을 때 쓰는 통신 규약**
  - Hyper Text의 전송을 목적으로 설계된 Application 레벨의 프로토콜
  - 텍스트 교환
  - **Hyper Text** : 클라이언트의 선택에 따라서 이동이 가능한 조직화된 정보
    - 이동이 가능한 텍스트를 의미한다.
  - Serverless 프로토콜
    - 서버는 클라이언트의 상태정보를 유지하지 않는다.
    - 클라이언트가 다시 요청을 해도 이 클라이언트가 조금전에 한차례 요청을 했던 클라이언트임을 인식하지 못한다.

- ### HTTPS(HypterText Transfer Protocol Secure) 는 보완기능까지 추가되어있다.
  - 중간에 가로채는 경우를 막기위해서.
  - 텍스트를 암호화 시킨다.
  - `주의 요함` , `안전하지 않은 사이트` 와 같은 알림으로 주의를 받는다.

[[🔝위로가기]](#)

<br>

> ## GET과 POST방식

[[🔝위로가기]](#)

<br>

> ## Stack과 Queue 정의

- ### Stack

  - **후입선출 (Last In First Out)**
  - 먼저 들어간 요소가 맨 나중에 나오는 구조로 되어있다.
  - 맨나중에 들어간 요소가 맨처음으로 나올 수있도록 함.

- ### Queue
  - **선입선출 (First In Last Out)**
  - 먼저 들어간 요소가 먼저 나오는 구조로 되어있다.

[[🔝위로가기]](#)

<br>

> ## 인덱스(INDEX)

- 인덱스는 데이터레코드를 빠르게 접근하기 위해 `<key값, 포인터>` 쌍으로 구성되는 데이터 구조이다.
- 데이터가 저장된 물리적 구조와 밀접한 관계가 있다.
- 인덱스는 레코드가 저장된 물리적 구조에 접근하는 방법을 제공한다.

[[🔝위로가기]](#)


> ## TCP 와 UDP

> ### TCP(Transmission Control Protocol)

- 인터넷상에서 데이터를 메시지의 형태로 보내기 위해 IP와 함께 사용하는 프로토콜

- **신뢰성있는 데이터전송** 을 지원하는 **연결지향형** 프로토콜 이다.
- 데이터전송에 신뢰성을 위해 `데이터 세그먼트` 단위로 분할한다.
- 전송속도를 조정하며 **데이터가 제대로 전달 되지 않았을 경우 재전송**을 요청한다.

- UDP에 비해 속도가 느리다.
- 흐름제어와 혼잡제어를 지원하여 데이터의 순서를 보장한다.
  - 흐름제어
  - 혼잡제어

- 참고자료: https://github.com/HyeminNoh/Tech-Stack/blob/master/docs/Network/TCP_and_UDP.md

<br>

> ### UDP

[[🔝위로가기]](#)

<br>
